-- Pet Spawner Backend (GUI-free)
local player = game.Players.LocalPlayer
local load = require(game.ReplicatedStorage:WaitForChild("Fsys")).load

-- Core Services
local clientData = load("ClientData")
local items = load("KindDB")
local router = load("RouterClient")
local downloader = load("DownloadClient")
local animationManager = load("AnimationManager")
local petRigs = load("new:PetRigs")

-- Pet Storage
local petModels = {}
local pets = {}
local equippedPet = nil
local mountedPet = nil
local currentMountTrack = nil

-- Utilities
local HttpService = game:GetService("HttpService")
local function getUniqueId()
    return HttpService:GenerateGUID(false)
end

local function getPetModel(kind)
    if petModels[kind] then return petModels[kind] end
    local streamed = downloader.promise_download_copy("Pets", kind):expect()
    petModels[kind] = streamed
    return streamed
end

-- Update client data helper
local function updateData(key, action)
    local data = clientData.get(key)
    local clonedData = table.clone(data)
    clientData.predict(key, action(clonedData))
end

-- Pet creation
local function createPet(id, properties)
    local uniqueId = getUniqueId()
    local pet = nil

    updateData("inventory", function(inventory)
        local newPets = table.clone(inventory.pets)
        local item = items[id]
        pet = {
            unique = uniqueId,
            category = "pets",
            id = id,
            kind = item.kind,
            newness_order = 0,
            properties = properties
        }
        newPets[uniqueId] = pet
        inventory.pets = newPets
        return inventory
    end)

    pets[uniqueId] = {data = pet, model = nil}
    return pet
end

-- Apply neon/mega neon visuals
local function neonify(model, entry)
    local petModel = model:FindFirstChild("PetModel")
    if not petModel then return end
    for neonPart, configuration in pairs(entry.neon_parts or {}) do
        local truePart = petRigs.get(petModel).get_geo_part(petModel, neonPart)
        if truePart then
            truePart.Material = configuration.Material
            truePart.Color = configuration.Color
        end
    end
end

-- Equip / Unequip
local function addPetWrapper(wrapper)
    updateData("pet_char_wrappers", function(petWrappers)
        wrapper.unique = #petWrappers + 1
        wrapper.index = #petWrappers + 1
        petWrappers[#petWrappers + 1] = wrapper
        return petWrappers
    end)
end

local function addPetState(state)
    updateData("pet_state_managers", function(petStates)
        petStates[#petStates + 1] = state
        return petStates
    end)
end

local function removePetWrapper(uniqueId)
    updateData("pet_char_wrappers", function(petWrappers)
        for i, w in ipairs(petWrappers) do
            if w.pet_unique == uniqueId then
                table.remove(petWrappers, i)
                break
            end
        end
        for idx, w in ipairs(petWrappers) do
            w.unique = idx
            w.index = idx
        end
        return petWrappers
    end)
end

local function clearPetState(uniqueId)
    local pet = pets[uniqueId]
    if not pet or not pet.model then return end
    updateData("pet_state_managers", function(states)
        for i, state in ipairs(states) do
            if state.char == pet.model then
                local clone = table.clone(states[i])
                clone.states = {}
                states[i] = clone
                break
            end
        end
        return states
    end)
end

local function equip(item)
    if equippedPet then
        unequip(equippedPet)
    end
    local petModel = getPetModel(item.kind):Clone()
    petModel.Parent = workspace
    pets[item.unique].model = petModel

    if item.properties.neon or item.properties.mega_neon then
        neonify(petModel, items[item.kind])
    end

    equippedPet = item

    addPetWrapper({
        char = petModel,
        mega_neon = item.properties.mega_neon,
        neon = item.properties.neon,
        player = player,
        entity_controller = player,
        controller = player,
        rp_name = item.properties.rp_name or "",
        pet_trick_level = item.properties.pet_trick_level,
        pet_unique = item.unique,
        pet_id = item.id,
        location = {
            full_destination_id = "housing",
            destination_id = "housing",
            house_owner = player
        },
        pet_progression = {
            friendship_level = item.properties.friendship_level,
            age = item.properties.age,
            percentage = 0
        },
        are_colors_sealed = false,
        is_pet = true
    })

    addPetState({
        char = petModel,
        player = player,
        store_key = "pet_state_managers",
        is_sitting = false,
        chars_connected_to_me = {},
        states = {}
    })
end

local function unequip(item)
    local pet = pets[item.unique]
    if not pet or not pet.model then return end

    removePetWrapper(item.unique)
    clearPetState(item.unique)
    pet.model:Destroy()
    pet.model = nil
    equippedPet = nil
end

-- Pet lookup
local Loads = require(game.ReplicatedStorage.Fsys).load
local InventoryDB = Loads("InventoryDB")

local function GetPetByName(name)
    for _, v in pairs(InventoryDB.pets) do
        if v.name:lower() == name:lower() then
            return v.id
        end
    end
    return false
end

-- Expose backend functions for your own GUI
return {
    createPet = createPet,
    equipPet = equip,
    unequipPet = unequip,
    getPetByName = GetPetByName,
    pets = pets
}
