task.spawn(
	function()
		local load = require(game.ReplicatedStorage:WaitForChild("Fsys")).load

		set_thread_identity(2)
		local clientData = load("ClientData")
		local items = load("KindDB")
		local router = load("RouterClient")
		local downloader = load("DownloadClient")
		local animationManager = load("AnimationManager")
		local petRigs = load("new:PetRigs")
		set_thread_identity(8)

		local petModels = {}
		local pets = {}
		local equippedPet = nil
		local mountedPet = nil
		local currentMountTrack = nil

		local function updateData(key, action)
			local data = clientData.get(key)
			local clonedData = table.clone(data)
			clientData.predict(key, action(clonedData))
		end

		local function getUniqueId()
			local HttpService = game:GetService("HttpService")
			return HttpService:GenerateGUID(false)
		end

		local function getPetModel(kind)
			if petModels[kind] then
				return petModels[kind]
			end
			local streamed = downloader.promise_download_copy("Pets", kind):expect()
			petModels[kind] = streamed
			return streamed
		end

		local function createPet(id, properties)
			local uniqueId = getUniqueId()
			local pet = nil

			set_thread_identity(2)
			updateData(
				"inventory",
				function(inventory)
					local newPets = table.clone(inventory.pets)
					local item = items[id]
					pet = {
						unique = uniqueId,
						category = "pets",
						id = id,
						kind = item.kind,
						newness_order = 0,
						properties = properties
					}
					newPets[uniqueId] = pet
					inventory.pets = newPets
					return inventory
				end
			)

			set_thread_identity(8)
			pets[uniqueId] = {data = pet, model = nil}
			return pet
		end

		local function neonify(model, entry)
			local petModel = model:FindFirstChild("PetModel")
			if not petModel then
				return
			end
			for neonPart, configuration in pairs(entry.neon_parts) do
				local trueNeonPart = petRigs.get(petModel).get_geo_part(petModel, neonPart)
				trueNeonPart.Material = configuration.Material
				trueNeonPart.Color = configuration.Color
			end
		end

		local function addPetWrapper(wrapper)
			updateData(
				"pet_char_wrappers",
				function(petWrappers)
					wrapper.unique = #petWrappers + 1
					wrapper.index = #petWrappers + 1
					petWrappers[#petWrappers + 1] = wrapper
					return petWrappers
				end
			)
		end

		local function addPetState(state)
			updateData(
				"pet_state_managers",
				function(petStates)
					petStates[#petStates + 1] = state
					return petStates
				end
			)
		end

		local function findIndex(array, finder)
			for index, value in pairs(array) do
				if finder(value, index) then
					return index
				end
			end
			return nil
		end

		local function removePetWrapper(uniqueId)
			updateData(
				"pet_char_wrappers",
				function(petWrappers)
					local index =
						findIndex(
							petWrappers,
							function(wrapper)
								return wrapper.pet_unique == uniqueId
							end
						)
					if not index then
						return petWrappers
					end
					table.remove(petWrappers, index)
					for wrapperIndex, wrapper in pairs(petWrappers) do
						wrapper.unique = wrapperIndex
						wrapper.index = wrapperIndex
					end
					return petWrappers
				end
			)
		end

		local function clearPetState(uniqueId)
			local pet = pets[uniqueId]
			if not pet or not pet.model then
				return
			end
			updateData(
				"pet_state_managers",
				function(states)
					local index =
						findIndex(
							states,
							function(state)
								return state.char == pet.model
							end
						)
					if not index then
						return states
					end
					local clonedStates = table.clone(states)
					clonedStates[index] = table.clone(clonedStates[index])
					clonedStates[index].states = {}
					return clonedStates
				end
			)
		end

		local function setPetState(uniqueId, id)
			local pet = pets[uniqueId]
			if not pet or not pet.model then
				return
			end
			updateData(
				"pet_state_managers",
				function(states)
					local index =
						findIndex(
							states,
							function(state)
								return state.char == pet.model
							end
						)
					if not index then
						return states
					end
					local clonedStates = table.clone(states)
					clonedStates[index] = table.clone(clonedStates[index])
					clonedStates[index].states = {{id = id}}
					return clonedStates
				end
			)
		end

		local function attachPlayerToPet(pet)
			local character = game.Players.LocalPlayer.Character
			if not character or not character.PrimaryPart then
				return false
			end
			local ridePosition = pet:FindFirstChild("RidePosition", true)
			if not ridePosition then
				return false
			end

			local sourceAttachment = Instance.new("Attachment")
			sourceAttachment.Parent = ridePosition
			sourceAttachment.Position = Vector3.new(0, 1.237, 0)
			sourceAttachment.Name = "SourceAttachment"

			local stateConnection = Instance.new("RigidConstraint")
			stateConnection.Name = "StateConnection"
			stateConnection.Attachment0 = sourceAttachment
			stateConnection.Attachment1 = character.PrimaryPart.RootAttachment
			stateConnection.Parent = character
			return true
		end

		local function clearPlayerState()
			updateData(
				"state_manager",
				function(state)
					local clonedState = table.clone(state)
					clonedState.states = {}
					clonedState.is_sitting = false
					return clonedState
				end
			)
		end

		local function setPlayerState(id)
			updateData(
				"state_manager",
				function(state)
					local clonedState = table.clone(state)
					clonedState.states = {{id = id}}
					clonedState.is_sitting = true
					return clonedState
				end
			)
		end

		local function removePetState(uniqueId)
			local pet = pets[uniqueId]
			if not pet or not pet.model then
				return
			end
			updateData(
				"pet_state_managers",
				function(petStates)
					local index =
						findIndex(
							petStates,
							function(state)
								return state.char == pet.model
							end
						)
					if not index then
						return petStates
					end
					table.remove(petStates, index)
					return petStates
				end
			)
		end

		local function unmount(uniqueId)
			local pet = pets[uniqueId]
			if not pet or not pet.model then
				return
			end
			if currentMountTrack then
				currentMountTrack:Stop()
				currentMountTrack:Destroy()
			end
			local sourceAttachment = pet.model:FindFirstChild("SourceAttachment", true)
			if sourceAttachment then
				sourceAttachment:Destroy()
			end
			if game.Players.LocalPlayer.Character then
				for _, d in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do
					if d:IsA("BasePart") and d:GetAttribute("HaveMass") then
						d.Massless = false
					end
				end
			end
			clearPetState(uniqueId)
			clearPlayerState()
			pet.model:ScaleTo(1)
			mountedPet = nil
		end

		local function mount(uniqueId, playerState, petState)
			local pet = pets[uniqueId]
			if not pet or not pet.model then
				return
			end
			local player = game.Players.LocalPlayer
			if not player.Character or not player.Character.PrimaryPart then
				return
			end
			mountedPet = uniqueId
			setPetState(uniqueId, petState)
			setPlayerState(playerState)
			pet.model:ScaleTo(2)
			attachPlayerToPet(pet.model)
			currentMountTrack =
				player.Character.Humanoid.Animator:LoadAnimation(animationManager.get_track("PlayerRidingPet"))
			player.Character.Humanoid.Sit = true
			for _, d in pairs(player.Character:GetDescendants()) do
				if d:IsA("BasePart") and d.Massless == false then
					d.Massless = true
					d:SetAttribute("HaveMass", true)
				end
			end
			currentMountTrack:Play()
		end

		local function fly(uniqueId)
			mount(uniqueId, "PlayerFlyingPet", "PetBeingFlown")
		end
		local function ride(uniqueId)
			mount(uniqueId, "PlayerRidingPet", "PetBeingRidden")
		end

		local function unequip(item)
			local pet = pets[item.unique]
			if not pet or not pet.model then
				return
			end
			unmount(item.unique)
			removePetWrapper(item.unique)
			removePetState(item.unique)
			pet.model:Destroy()
			pet.model = nil
			equippedPet = nil
		end

		local function equip(item)
			if equippedPet then
				unequip(equippedPet)
			end
			local petModel = getPetModel(item.kind):Clone()
			petModel.Parent = workspace
			pets[item.unique].model = petModel
			if item.properties.neon or item.properties.mega_neon then
				neonify(petModel, items[item.kind])
			end
			equippedPet = item
			addPetWrapper(
				{
					char = petModel,
					mega_neon = item.properties.mega_neon,
					neon = item.properties.neon,
					player = game.Players.LocalPlayer,
					entity_controller = game.Players.LocalPlayer,
					controller = game.Players.LocalPlayer,
					rp_name = item.properties.rp_name or "",
					pet_trick_level = item.properties.pet_trick_level,
					pet_unique = item.unique,
					pet_id = item.id,
					location = {
						full_destination_id = "housing",
						destination_id = "housing",
						house_owner = game.Players.LocalPlayer
					},
					pet_progression = {
						friendship_level = item.properties.friendship_level,
						age = item.properties.age,
						percentage = 0
					},
					are_colors_sealed = false,
					is_pet = true
				}
			)
			addPetState(
				{
					char = petModel,
					player = game.Players.LocalPlayer,
					store_key = "pet_state_managers",
					is_sitting = false,
					chars_connected_to_me = {},
					states = {}
				}
			)
		end

		local oldGet = router.get
		local function createRemoteFunctionMock(callback)
			return {
				InvokeServer = function(_, ...)
					return callback(...)
				end
			}
		end
		local function createRemoteEventMock(callback)
			return {
				FireServer = function(_, ...)
					return callback(...)
				end
			}
		end

		local equipRemote =
			createRemoteFunctionMock(
				function(uniqueId, metadata)
					local pet = pets[uniqueId]
					if not pet then
						return
					end
					equip(pet.data)
					return true, {action = "equip", is_server = true}
				end
			)
		local unequipRemote =
			createRemoteFunctionMock(
				function(uniqueId)
					local pet = pets[uniqueId]
					if not pet then
						return
					end
					unequip(pet.data)
					return true, {action = "unequip", is_server = true}
				end
			)
		local rideRemote =
			createRemoteFunctionMock(
				function(item)
					ride(item.pet_unique)
				end
			)
		local flyRemote =
			createRemoteFunctionMock(
				function(item)
					fly(item.pet_unique)
				end
			)
		local unmountRemoteFunction =
			createRemoteFunctionMock(
				function()
					unmount(mountedPet)
				end
			)
		local unmountRemoteEvent =
			createRemoteEventMock(
				function()
					unmount(mountedPet)
				end
			)

		router.get = function(name)
			if name == "ToolAPI/Equip" then
				return equipRemote
			end
			if name == "ToolAPI/Unequip" then
				return unequipRemote
			end
			if name == "AdoptAPI/RidePet" then
				return rideRemote
			end
			if name == "AdoptAPI/FlyPet" then
				return flyRemote
			end
			if name == "AdoptAPI/ExitSeatStatesYield" then
				return unmountRemoteFunction
			end
			if name == "AdoptAPI/ExitSeatStates" then
				return unmountRemoteEvent
			end
			return oldGet(name)
		end

		for _, charWrapper in pairs(clientData.get("pet_char_wrappers")) do
			oldGet("ToolAPI/Unequip"):InvokeServer(charWrapper.pet_unique)
		end

		local Loads = require(game.ReplicatedStorage.Fsys).load
		local InventoryDB = Loads("InventoryDB")

		function GetPetByName(name)
			for i, v in pairs(InventoryDB.pets) do
				if v.name:lower() == name:lower() then
					return v.id
				end
			end
			return false
		end

		--// LocalScript: Pet Spawner GUI

		local Players = game:GetService("Players")
		local UIS = game:GetService("UserInputService")
		local player = Players.LocalPlayer

		-- GUI
		local ScreenGui = Instance.new("ScreenGui")
		ScreenGui.Name = "PetSpawnerGUI"
		ScreenGui.Parent = player:WaitForChild("PlayerGui")
		ScreenGui.ResetOnSpawn = false

		local Frame = Instance.new("Frame")
		Frame.Size = UDim2.new(0, 380, 0, 250)
		Frame.Position = UDim2.new(0.5, -190, 0.5, -125)
		Frame.BackgroundColor3 = Color3.fromRGB(255, 182, 193) -- light pink
		Frame.BorderSizePixel = 0
		Frame.Parent = ScreenGui
		Instance.new("UICorner", Frame).CornerRadius = UDim.new(0, 12)
		
		-- Neon Outline
		local outline = Instance.new("UIStroke")
		outline.Thickness = 3
		outline.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
		outline.Parent = Frame

		-- Rainbow neon effect
		local RunService = game:GetService("RunService")
		local hue = 0
		RunService.RenderStepped:Connect(function(deltaTime)
			hue = (hue + deltaTime * 0.2) % 1
			outline.Color = Color3.fromHSV(hue, 1, 1)
		end)


		-- HEADER
		local Header = Instance.new("Frame")
		Header.Size = UDim2.new(1, 0, 0, 40)
		Header.BackgroundTransparency = 1
		Header.Parent = Frame

		local Title = Instance.new("TextLabel")
		Title.Size = UDim2.new(1, 0, 1, 0)
		Title.BackgroundTransparency = 1
		Title.Text = "‚≠êROYAL SPAWNER"
		Title.TextColor3 = Color3.fromRGB(255, 255, 255)
		Title.Font = Enum.Font.GothamBold
		Title.TextScaled = true
		Title.Parent = Header

		-- MINIMIZE / EXPAND BUTTONS
		local MinBtn = Instance.new("TextButton")
		MinBtn.Size = UDim2.new(0, 30, 0, 30)
		MinBtn.Position = UDim2.new(1, -70, 0, 5)
		MinBtn.Text = "-"
		MinBtn.Font = Enum.Font.GothamBold
		MinBtn.TextScaled = true
		MinBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
		MinBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
		MinBtn.Parent = Header
		Instance.new("UICorner", MinBtn).CornerRadius = UDim.new(0, 4)

		local ExpandBtn = Instance.new("TextButton")
		ExpandBtn.Size = UDim2.new(0, 30, 0, 30)
		ExpandBtn.Position = UDim2.new(1, -70, 0, 5)
		ExpandBtn.Text = "+"
		ExpandBtn.Visible = false
		ExpandBtn.Font = Enum.Font.GothamBold
		ExpandBtn.TextScaled = true
		ExpandBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
		ExpandBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
		ExpandBtn.Parent = Header
		Instance.new("UICorner", ExpandBtn).CornerRadius = UDim.new(0, 4)

		-- DRAG LOGIC (HEADER or TITLE)
		local dragging = false
		local dragInput, dragStart, startPos

		local function update(input)
			if not dragging then return end
			local delta = input.Position - dragStart
			Frame.Position = UDim2.new(
				startPos.X.Scale,
				startPos.X.Offset + delta.X,
				startPos.Y.Scale,
				startPos.Y.Offset + delta.Y
			)
		end

		-- Connect both Header and Title to drag
		for _, dragObj in pairs({Header, Title}) do
			dragObj.InputBegan:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
					dragging = true
					dragStart = input.Position
					startPos = Frame.Position
					input.Changed:Connect(function()
						if input.UserInputState == Enum.UserInputState.End then
							dragging = false
						end
					end)
				end
			end)

			dragObj.InputChanged:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
					dragInput = input
				end
			end)
		end

		UIS.InputChanged:Connect(function(input)
			if input == dragInput and dragging then
				update(input)
			end
		end)

		-- MINIMIZE / EXPAND LOGIC
		-- ==========================
		-- FIXED MINIMIZE SYSTEM
		-- ==========================

		local TweenService = game:GetService("TweenService")
		local savedVisibility = {}

		local fullSize = UDim2.new(0, 380, 0, 250)
		local minimizedSize = UDim2.new(0, 380, 0, 40)

		local function hideAllContent()
			savedVisibility = {}
			for _, obj in ipairs(Frame:GetDescendants()) do
				if obj:IsA("GuiObject")
					and obj ~= Header
					and obj ~= MinBtn
					and obj ~= ExpandBtn
					and not obj:IsDescendantOf(Header) then

					savedVisibility[obj] = obj.Visible
					obj.Visible = false
				end
			end
		end

		local function restoreAllContent()
			for obj, state in pairs(savedVisibility) do
				if obj and obj.Parent then
					obj.Visible = state
				end
			end
			savedVisibility = {}
		end

		MinBtn.MouseButton1Click:Connect(function()
			TweenService:Create(Frame, TweenInfo.new(0.25), {Size = minimizedSize}):Play()
			hideAllContent()
			MinBtn.Visible = false
			ExpandBtn.Visible = true
		end)

		ExpandBtn.MouseButton1Click:Connect(function()
			TweenService:Create(Frame, TweenInfo.new(0.25), {Size = fullSize}):Play()
			restoreAllContent()
			MinBtn.Visible = true
			ExpandBtn.Visible = false
		end)


		MinBtn.MouseButton1Click:Connect(function()
			toggleContent(false)
			MinBtn.Visible = false
			ExpandBtn.Visible = true
		end)

		ExpandBtn.MouseButton1Click:Connect(function()
			toggleContent(true)
			MinBtn.Visible = true
			ExpandBtn.Visible = false
		end)


		--// PET NAME INPUT
		local PetBox = Instance.new("TextBox")
		PetBox.Size = UDim2.new(0.9, 0, 0, 40)
		PetBox.Position = UDim2.new(0.05, 0, 0, 60)
		PetBox.PlaceholderText = "Enter Pet Name"
		PetBox.Text = ""
		PetBox.TextColor3 = Color3.fromRGB(255, 255, 255)
		PetBox.Font = Enum.Font.Gotham
		PetBox.TextScaled = true
		PetBox.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
		PetBox.Parent = Frame
		Instance.new("UICorner", PetBox).CornerRadius = UDim.new(0, 8)

		--// TYPE BUTTONS
		local selectedType = "FR"
		local function makeTypeButton(txt, color, xPos)
			local btn = Instance.new("TextButton")
			btn.Size = UDim2.new(0, 90, 0, 40)
			btn.Position = UDim2.new(0, xPos, 0, 115)
			btn.Text = txt
			btn.TextScaled = true
			btn.Font = Enum.Font.GothamBold
			btn.BackgroundColor3 = color
			btn.TextColor3 = Color3.fromRGB(255, 255, 255)
			btn.Parent = Frame
			Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 8)

			btn.MouseButton1Click:Connect(function()
				selectedType = txt
				print("Selected:", txt)
			end)
			return btn
		end

		local MFR = makeTypeButton("MFR", Color3.fromRGB(255, 100, 100), 20)
		local NFR = makeTypeButton("NFR", Color3.fromRGB(100, 255, 100), 145)
		local FR  = makeTypeButton("FR",  Color3.fromRGB(120, 120, 255), 270)

		--// SPAWN BUTTON
		local SpawnBtn = Instance.new("TextButton")
		SpawnBtn.Size = UDim2.new(0.9, 0, 0, 45)
		SpawnBtn.Position = UDim2.new(0.05, 0, 0, 170)
		SpawnBtn.Text = "Spawn Pet"
		SpawnBtn.Font = Enum.Font.GothamBold
		SpawnBtn.TextScaled = true
		SpawnBtn.BackgroundColor3 = Color3.fromRGB(50, 100, 255)
		SpawnBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
		SpawnBtn.Parent = Frame
		Instance.new("UICorner", SpawnBtn).CornerRadius = UDim.new(0, 8)

		--// SPAWN CONFIRMATION LABEL
		local ConfirmLabel = Instance.new("TextLabel")
		ConfirmLabel.Size = UDim2.new(0.9, 0, 0, 30)
		ConfirmLabel.Position = UDim2.new(0.05, 0, 0, 225)
		ConfirmLabel.BackgroundTransparency = 1
		ConfirmLabel.TextColor3 = Color3.fromRGB(0, 255, 0)
		ConfirmLabel.Font = Enum.Font.GothamBold
		ConfirmLabel.TextScaled = true
		ConfirmLabel.Text = ""
		ConfirmLabel.Parent = Frame

		----------------------------------------------------------

		SpawnBtn.MouseButton1Click:Connect(function()

			if not selectedType then
				ConfirmLabel.Text = "Select FR / NFR / MFR first!"
				ConfirmLabel.TextColor3 = Color3.fromRGB(255, 120, 120)
				return
			end

			local petName = PetBox.Text
			if petName == "" then
				ConfirmLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
				ConfirmLabel.Text = "Error: Enter a pet name!"
				return
			end

			local petId = GetPetByName(petName)
			if not petId then
				ConfirmLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
				ConfirmLabel.Text = "Error: Pet not found!"
				return
			end

			-- Shared base data
			local baseData = {
				pet_trick_level = 0,
				rideable = true,
				flyable = true,
				friendship_level = 0,
				age = 1,
				rp_name = "",
				ailments_completed = 0,
			}

			if selectedType == "FR" then
				createPet(petId, baseData)

			elseif selectedType == "NFR" then
				local data = baseData
				data.neon = true
				createPet(petId, data)

			elseif selectedType == "MFR" then
				local data = baseData
				data.mega_neon = true
				createPet(petId, data)
			end

			-- SUCCESS MESSAGE
			ConfirmLabel.TextColor3 = Color3.fromRGB(0, 255, 0)
			ConfirmLabel.Text = "Pet Spawned: " .. petName .. " (" .. selectedType .. ")"

			-- Make SelectedLabel turn GREEN after spawn
			SelectedLabel.TextColor3 = Color3.fromRGB(0, 255, 0)
		end)

	end	
)
